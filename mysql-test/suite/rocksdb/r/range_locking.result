show variables like 'rocksdb_use_range_locking';
Variable_name	Value
rocksdb_use_range_locking	ON
create table t1 (
pk int primary key,
a int
) engine=rocksdb;
insert into t1 values
(10,10),(20,20),(30,30);
connect  con1,localhost,root,,;
connect  con2,localhost,root,,;
### Test: check that range lock inhibits a point lock
connection con1;
begin;
select * from t1 where pk between 5 and 25 for update;
pk	a
10	10
20	20
connection con2;
insert into t1 values (15,15);
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.PRIMARY
connection con1;
rollback;
## Test: check that range lock inhibits another range lock
##  (It should not, but currently it does)
connection con1;
begin;
select * from t1 where pk between 5 and 25 for update;
pk	a
10	10
20	20
connection con2;
begin;
select * from t1 where pk between 15 and 35 for update;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.PRIMARY
rollback;
connection con1;
rollback;
## Test: check that regular read does not get a range lock
connection con1;
begin;
select * from t1 where pk between 5 and 25;
pk	a
10	10
20	20
connection con2;
begin;
select * from t1 where pk between 15 and 35 for update;
pk	a
20	20
30	30
rollback;
connection con1;
rollback;
## Test that locks are not released when a statement in the transaction
create table t2 (
pk int primary key,
a int,
unique key(a)
) engine=rocksdb;
insert into t2 values (1,1),(2,2);
begin;
insert into t2 values (3,3);
insert into t2 values (10,2);
ERROR 23000: Duplicate entry '2' for key 'a'
connection con2;
begin;
select * from t2 where pk=3 for update;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t2.PRIMARY
rollback;
connection con1;
rollback;
drop table t2;
connection default;
disconnect con1;
disconnect con2;
drop table t1;
#
# Test INFORMATION_SCHEMA.lock_info in range-locking mode
#
create table t1 (
pk int primary key,
a int
) engine=rocksdb;
insert into t1 values
(10,10),(20,20),(30,30);
begin;
select * from t1 where pk=10 for update;
pk	a
10	10
select * from information_schema.rocksdb_locks;
COLUMN_FAMILY_ID	TRANSACTION_ID	KEY	MODE
0	15	00000001078000000a	X
delete from t1 where pk between 25 and 40;
select * from information_schema.rocksdb_locks;
COLUMN_FAMILY_ID	TRANSACTION_ID	KEY	MODE
0	15	000000010780000019 - 010000010780000028	X
0	15	00000001078000000a	X
rollback;
begin;
# The following will show a range lock on 2-9 and also a point lock on 10.
# This is how things currently work.
select * from t1 where pk between 2 and 9 for update;
pk	a
select * from information_schema.rocksdb_locks;
COLUMN_FAMILY_ID	TRANSACTION_ID	KEY	MODE
0	16	00000001078000000a	X
0	16	000000010780000002 - 010000010780000009	X
rollback;
drop table t1;
#
# MDEV-18104: MyRocks-Gap-Lock: range locking bounds are incorrect for multi-part keys
#
create table t0(a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (
kp1 int not null,
kp2 int not null,
a int,
primary key(kp1, kp2)
) engine=rocksdb;
insert into t1 select 1, a, 1234 from t0;
insert into t1 select 2, a, 1234 from t0;
insert into t1 select 3, a, 1234 from t0;
connect  con1,localhost,root,,;
connection con1;
begin;
select * from t1 where kp1=2 for update;
kp1	kp2	a
2	0	1234
2	1	1234
2	2	1234
2	3	1234
2	4	1234
2	5	1234
2	6	1234
2	7	1234
2	8	1234
2	9	1234
connection default;
# The lock on kp1=2 should inhibit the following INSERT:
insert into t1 values ( 2,5,9999);
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.PRIMARY
rollback;
connection con1;
rollback;
connection default;
disconnect con1;
drop table t0,t1;
#
# Test that locks on ranges on non-unique secondary keys inhibit
# modifications of the contents of these ranges
#
create table t0(a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (
kp1 int not null,
kp2 int not null,
a int,
key(kp1, kp2)
) engine=rocksdb;
insert into t1 select  1, a, 1234 from t0;
insert into t1 values (2, 3, 1234);
insert into t1 values (2, 5, 1234);
insert into t1 values (2, 7, 1234);
insert into t1 select  3, a, 1234 from t0;
connect  con1,localhost,root,,;
connection con1;
begin;
explain
select * from t1 where kp1=2 for update;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	kp1	kp1	4	const	#	NULL
select * from t1 where kp1=2 for update;
kp1	kp2	a
2	3	1234
2	5	1234
2	7	1234
connection default;
begin;
insert into t1 values (2, 9, 9999);
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.kp1
delete from t1 where kp1=2 and kp2=5;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.kp1
update t1 set kp1=333 where kp1=2 and kp2=3;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.kp1
update t1 set kp1=2 where kp1=1 and kp2=8;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.kp1
rollback;
connection con1;
rollback;
disconnect con1;
connection default;
drop table t0,t1;
