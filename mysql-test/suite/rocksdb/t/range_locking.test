#
#  Range locking tests.
#

--source include/have_rocksdb.inc
--enable_connect_log


show variables like 'rocksdb_use_range_locking';

# Test 1: see that ranges are indeed lockied.

create table t1 (
  pk int primary key,
  a int
) engine=rocksdb;

insert into t1 values
(10,10),(20,20),(30,30);

connect (con1,localhost,root,,);
connect (con2,localhost,root,,);

--echo ### Test: check that range lock inhibits a point lock
connection con1;
begin;
select * from t1 where pk between 5 and 25 for update;

connection con2;
--error ER_LOCK_WAIT_TIMEOUT
insert into t1 values (15,15);

connection con1;
rollback;

--echo ## Test: check that range lock inhibits another range lock
--echo ##  (It should not, but currently it does)
connection con1;
begin;
select * from t1 where pk between 5 and 25 for update;

connection con2;
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t1 where pk between 15 and 35 for update;
rollback;

connection con1;
rollback;

--echo ## Test: check that regular read does not get a range lock
connection con1;
begin;
select * from t1 where pk between 5 and 25;

connection con2;
begin;
# This must not block
select * from t1 where pk between 15 and 35 for update;
rollback;

connection con1;
rollback;

--echo ## Test that locks are not released when a statement in the transaction
create table t2 (
  pk int primary key,
  a int,
  unique key(a)
) engine=rocksdb;

insert into t2 values (1,1),(2,2);

begin;
insert into t2 values (3,3);
--error ER_DUP_ENTRY
insert into t2 values (10,2);

connection con2;
begin;
# This must time out:
--error ER_LOCK_WAIT_TIMEOUT
select * from t2 where pk=3 for update;

rollback;
connection con1;
rollback;
drop table t2;

# Cleanup
connection default;
disconnect con1;
disconnect con2;
drop table t1;

--echo #
--echo # Test INFORMATION_SCHEMA.lock_info in range-locking mode
--echo #
create table t1 (
  pk int primary key,
  a int
) engine=rocksdb;

insert into t1 values
(10,10),(20,20),(30,30);

begin;
select * from t1 where pk=10 for update;

select * from information_schema.rocksdb_locks;

delete from t1 where pk between 25 and 40;
select * from information_schema.rocksdb_locks;

rollback;
begin;
--echo # The following will show a range lock on 2-9 and also a point lock on 10.
--echo # This is how things currently work.
select * from t1 where pk between 2 and 9 for update;
select * from information_schema.rocksdb_locks;
rollback;

drop table t1;

--echo #
--echo # MDEV-18104: MyRocks-Gap-Lock: range locking bounds are incorrect for multi-part keys
--echo #

create table t0(a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (
  kp1 int not null,
  kp2 int not null,
  a int,
  primary key(kp1, kp2)
) engine=rocksdb;

insert into t1 select 1, a, 1234 from t0;
insert into t1 select 2, a, 1234 from t0;
insert into t1 select 3, a, 1234 from t0;

connect (con1,localhost,root,,);
connection con1;

begin;
select * from t1 where kp1=2 for update;

connection default;
--echo # The lock on kp1=2 should inhibit the following INSERT:
--error ER_LOCK_WAIT_TIMEOUT
insert into t1 values ( 2,5,9999); 
rollback;

connection con1;
rollback;
connection default;
disconnect con1;

drop table t0,t1;
